{"version":3,"sources":["components/tile.jsx","components/snake.jsx","utils/utils.js","App.js","reportWebVitals.js","index.js"],"names":["Tile","props","tileType","className","numRows","numCols","Snake","useState","tiles","setTiles","snake","setSnake","direction","setDirection","moveSnakeHead","newPos","snakeRow","snakeCol","newRow","newCol","move","newSnake","collectedPellet","i","length","newHeadPos","push","snakeTail","randRow","parseInt","Math","random","randCol","newTiles","spawnPellet","row","j","updateSnakePos","useEffect","initialTiles","initialSnake","initializeBoard","window","addEventListener","event","keyCode","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","map","outerIndex","tile","innerIndex","tileToDisplay","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uNAkBeA,MAJf,SAAcC,GACV,MAZgB,WADHC,EAaED,EAAMC,UAXT,qBAAKC,UAAU,iBAEN,UAAbD,EACI,qBAAKC,UAAU,iBAEN,WAAbD,EACI,qBAAKC,UAAU,uBADtB,EAPO,IAACD,GCEjB,IAAME,EAAU,GACVC,EAAU,GA+ODC,MAxOf,WAAkB,IAAD,EACaC,mBAAS,IADtB,mBACNC,EADM,KACCC,EADD,OAEaF,mBAAS,IAFtB,mBAENG,EAFM,KAECC,EAFD,OAGqBJ,mBAAS,GAH9B,mBAGNK,EAHM,KAGKC,EAHL,KAqGPC,EAAgB,WAClB,IAAIC,EAAS,GAGTC,EAAWN,EAAM,GAAG,GACpBO,EAAWP,EAAM,GAAG,GAExB,GAjHG,IAiHAE,EAAkB,CACjB,IAAIM,EAASF,EAAW,EAErBE,EAAS,IACRA,EAASd,IAGbW,EAAS,CAACG,EAAQD,QAEjB,GAzHA,IAyHGL,EAAoB,CACxB,IAAIO,EAASF,EAAW,EAErBE,EAAS,IACRA,EAASd,IAGbU,EAAS,CAACC,EAAUG,QAEnB,GAjIA,IAiIGP,EAAoB,CACxB,IAAIM,EAASF,EAAW,EAErBE,GAAUd,IACTc,EAAS,GAGbH,EAAS,CAACG,EAAQD,QAEjB,GAzIC,IAyIEL,EAAqB,CACzB,IAAIO,EAASF,EAAW,EAErBE,GAAUd,IACTc,EAAS,GAGbJ,EAAS,CAACC,EAAUG,GAGxB,OAAOJ,GAQLK,EAAO,WAKT,IAJA,IAAIC,EAAW,GACXN,EAASL,EAAM,GACfY,GAAkB,EAEdC,EAAI,EAAGA,EAAIb,EAAMc,OAAQD,IAAK,CAClC,GAAS,IAANA,EAAS,CACR,IAAME,EAAaX,IACnBO,EAASK,KAAKD,GAI6B,IAAxCjB,EAAMiB,EAAW,IAAIA,EAAW,MAC/BH,GAAkB,QAItBD,EAASK,KAAK,CAACX,EAAO,GAAIA,EAAO,KAErCA,EAASL,EAAMa,GAKnB,GAAGD,EAAiB,CAChB,IAAIK,EAAYjB,EAAMA,EAAMc,OAAS,GACrCH,EAASK,KAAKC,GAnJF,WAMhB,IAJA,IAAIC,EAAUC,SAASC,KAAKC,SAAW3B,GACnC4B,EAAUH,SAASC,KAAKC,SAAW1B,GAGL,IAA5BG,EAAMoB,GAASI,IACjBJ,EAAUC,SAASC,KAAKC,SAAW3B,GACnC4B,EAAUH,SAASC,KAAKC,SAAW1B,GAGvC,IAAI4B,EAAWzB,EACfyB,EAASL,GAASI,GAAW,EAC7BvB,EAASwB,GAuILC,IA9Ke,SAACb,GAGpB,IAFA,IAAIY,EAAW,GAEPV,EAAI,EAAGA,EAAIf,EAAMgB,OAAQD,IAAK,CAGlC,IAFA,IAAIY,EAAM,GAEFC,EAAI,EAAGA,EAAI5B,EAAMe,GAAGC,OAAQY,IACb,IAAhB5B,EAAMe,GAAGa,GACRD,EAAIT,KAAK,GAGTS,EAAIT,KAAKlB,EAAMe,GAAGa,IAI1BH,EAASP,KAAKS,GAGlB,IAAI,IAAIZ,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IAChCU,EAASZ,EAASE,GAAG,IAAIF,EAASE,GAAG,IAAM,EAG/CZ,EAASU,GACTZ,EAASwB,GA0JTI,CAAehB,IAqBnB,OAhBAiB,qBAAU,YA3Ic,WAGpB,IAFA,IAAIC,EAAe,GAEXhB,EAAI,EAAGA,EAAInB,EAASmB,IAAK,CAG7B,IAFA,IAAIY,EAAM,GAEFC,EAAI,EAAGA,EAAI/B,EAAS+B,IACxBD,EAAIT,KAAK,GAGba,EAAab,KAAKS,GAGtB,IAAIK,EAAe,CACf,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,IAIT7B,EAAS6B,GAGT,IAAI,IAAIjB,EAAI,EAAGA,EAAIiB,EAAahB,OAAQD,IACpCgB,EAAaC,EAAajB,GAAG,IAAIiB,EAAajB,GAAG,IAAM,EAI3D,IAAMK,EAAUC,SAASC,KAAKC,SAAW3B,GACnC4B,EAAUH,SAASC,KAAKC,SAAW1B,GACzCkC,EAAaX,GAASI,GAAW,EAEjCvB,EAAS8B,GA4GTE,GAGAC,OAAOC,iBAAiB,WAAW,SAACC,GA5GjB,IAACC,EACL,MADKA,EA6GDD,EAAMC,SA3GrBhC,EA3FD,GA6FiB,KAAZgC,EACJhC,EA7FC,GA+Fe,KAAZgC,EACJhC,EA/FC,GAiGe,KAAZgC,GACJhC,EAjGE,MAuMNA,EAvMM,KAwMP,IC/MA,SAAqBiC,EAAUC,GAClC,IAAMC,EAAgBC,mBAGtBX,qBAAU,WACRU,EAAcE,QAAUJ,IACvB,CAACA,IAGJR,qBAAU,WAIR,GAAc,OAAVS,EAAgB,CAClB,IAAII,EAAKC,aAJX,WACEJ,EAAcE,YAGaH,GAC3B,OAAO,kBAAMM,cAAcF,OAE5B,CAACJ,IDgMJO,EAAY,WACRlC,MACD,KAGC,sBAAKjB,UAAU,MAAf,UACI,qBAAKA,UAAU,aACf,sBAAKA,UAAU,cAAf,UACI,uCACCK,EAAM+C,KAAI,SAACpB,EAAKqB,GACb,OACI,qBAAsBrD,UAAU,MAAhC,SACKgC,EAAIoB,KAAI,SAACE,EAAMC,GACZ,IAAIC,EAAgB,cAAC,EAAD,CAAuBzD,SAAS,SAArBwD,GAS/B,OAPY,IAATD,EACCE,EAAgB,cAAC,EAAD,CAAuBzD,SAAS,SAArBwD,GAEd,IAATD,IACJE,EAAgB,cAAC,EAAD,CAAuBzD,SAAS,UAArBwD,IAGxBC,MAXLH,a,MErNnBI,MANf,WACE,OACE,cAAC,EAAD,KCMWC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.f9899824.chunk.js","sourcesContent":["import '../styles/snake.css';\n\nconst getTile = (tileType) => {\n    if(tileType === \"empty\") {\n        return (<div className=\"empty-square\"></div>);\n    }\n    else if(tileType === \"snake\") {\n        return (<div className=\"snake-square\"></div>);\n    }\n    else if(tileType === \"pellet\") {\n        return (<div className=\"pellet-square\"></div>);\n    }\n}\n\nfunction Tile(props) {\n    return getTile(props.tileType);\n}\n\nexport default Tile;\n","import { useState, useEffect } from 'react';\nimport Tile from './tile';\nimport { useInterval } from '../utils/utils';\n\nconst numRows = 30;\nconst numCols = 40;\n\nconst UP = 0;\nconst LEFT = 1;\nconst DOWN = 2;\nconst RIGHT = 3;\n\nfunction Snake() {\n    const [tiles, setTiles] = useState([]);\n    const [snake, setSnake] = useState([]);\n    const [direction, setDirection] = useState(0);\n\n\n    const updateSnakePos = (newSnake) => {\n        let newTiles = [];\n\n        for(let i = 0; i < tiles.length; i++) {\n            let row = [];\n\n            for(let j = 0; j < tiles[i].length; j++) {\n                if(tiles[i][j] === 1) {\n                    row.push(0);\n                }\n                else {\n                    row.push(tiles[i][j]);\n                }\n            }\n\n            newTiles.push(row);\n        }\n\n        for(let i = 0; i < newSnake.length; i++) {\n            newTiles[newSnake[i][0]][newSnake[i][1]] = 1;\n        }\n\n        setSnake(newSnake);\n        setTiles(newTiles);\n    }\n\n    const spawnPellet = () => {\n        // set a random tile to the pellet\n        let randRow = parseInt(Math.random() * numRows);\n        let randCol = parseInt(Math.random() * numCols);\n\n        // keep randomizing until the pellet spawns in an empty space\n        while(tiles[randRow][randCol] !== 0) {\n            randRow = parseInt(Math.random() * numRows);\n            randCol = parseInt(Math.random() * numCols);\n        }\n\n        let newTiles = tiles;\n        newTiles[randRow][randCol] = 2;\n        setTiles(newTiles);\n    }\n\n    // initialize tiles with snake and pellet\n    const initializeBoard = () => {\n        let initialTiles = [];\n\n        for(let i = 0; i < numRows; i++) {\n            let row = [];\n\n            for(let j = 0; j < numCols; j++) {\n                row.push(0);\n            }\n\n            initialTiles.push(row);\n        }\n\n        let initialSnake = [\n            [14, 5],\n            [14, 4],\n            [14, 3]\n        ];\n\n        // start snake in middle of board, may change this to not be hard coded\n        setSnake(initialSnake);\n\n        // set tiles with snake\n        for(let i = 0; i < initialSnake.length; i++) {\n            initialTiles[initialSnake[i][0]][initialSnake[i][1]] = 1;\n        }\n\n        // add a new pellet to the board\n        const randRow = parseInt(Math.random() * numRows);\n        const randCol = parseInt(Math.random() * numCols);\n        initialTiles[randRow][randCol] = 2;\n\n        setTiles(initialTiles);\n    }\n\n    const handleKeyPress = (keyCode) => {\n        if(keyCode === 87) {\n            setDirection(UP);\n        }\n        else if(keyCode === 65) {\n            setDirection(LEFT);\n        }\n        else if(keyCode === 83) {\n            setDirection(DOWN);\n        }\n        else if(keyCode === 68) {\n            setDirection(RIGHT);\n        }\n    }\n\n    // move the head of the snake in the current direction of movement\n    // wrap to the other side of the screen when a wall is encountered\n    const moveSnakeHead = () => {\n        let newPos = []\n\n        // get the head position of the snake\n        let snakeRow = snake[0][0];\n        let snakeCol = snake[0][1];\n\n        if(direction === UP) {\n            let newRow = snakeRow - 1;\n            \n            if(newRow < 0) {\n                newRow = numRows - 1;\n            }\n\n            newPos = [newRow, snakeCol];\n        }\n        else if(direction === LEFT) {\n            let newCol = snakeCol - 1;\n\n            if(newCol < 0) {\n                newCol = numCols - 1;\n            }\n\n            newPos = [snakeRow, newCol];\n        }\n        else if(direction === DOWN) {\n            let newRow = snakeRow + 1;\n\n            if(newRow >= numRows) {\n                newRow = 0;\n            }\n\n            newPos = [newRow, snakeCol];\n        }\n        else if(direction === RIGHT) {\n            let newCol = snakeCol + 1;\n\n            if(newCol >= numCols) {\n                newCol = 0;\n            }\n\n            newPos = [snakeRow, newCol];\n        }\n\n        return newPos;\n    }\n\n    // Move the snake by first moving the head in the direction of\n    // movement. For each piece of the snake after the head, move it to\n    // the position that came before it.\n    // e.g. move the piece directly after the head to the position that the\n    //      head was previously in\n    const move = () => {\n        let newSnake = [];\n        let newPos = snake[0]; // set to head initially\n        let collectedPellet = false;\n\n        for(let i = 0; i < snake.length; i++) {\n            if(i === 0) { // update head of snake based on direction of movement\n                const newHeadPos = moveSnakeHead();\n                newSnake.push(newHeadPos);\n\n                // if head of new snake is on a pellet, set collectedPellet\n                // to true so we can extend the length of the snake \n                if(tiles[newHeadPos[0]][newHeadPos[1]] === 2) {\n                    collectedPellet = true;\n                }\n            }\n            else {\n                newSnake.push([newPos[0], newPos[1]]);\n            }\n            newPos = snake[i];\n        }\n\n        // if a pellet was collected, keep the last position of the tail\n        // of the current snake to extend the new snakes length by one\n        if(collectedPellet) {\n            let snakeTail = snake[snake.length - 1];\n            newSnake.push(snakeTail);\n            spawnPellet()\n        }\n\n        updateSnakePos(newSnake);\n    }\n\n    // set the interval for the snake to move\n    // create listeners for key presses (wasd to move)\n    useEffect(() => {\n        initializeBoard();\n\n        // listen for key press events\n        window.addEventListener('keydown', (event) => {\n            handleKeyPress(event.keyCode);\n        });\n\n        // set initial direction to right\n        setDirection(RIGHT);\n    }, []);\n\n    useInterval(() => {\n        move();\n    }, 100);\n\n    return (\n        <div className=\"row\">\n            <div className=\"col-md-2\"></div>\n            <div className=\"text-center\">\n                <h1>snake</h1>\n                {tiles.map((row, outerIndex) => {\n                    return (\n                        <div key={outerIndex} className=\"row\">\n                            {row.map((tile, innerIndex) => {\n                                let tileToDisplay = <Tile key={innerIndex} tileType=\"empty\"></Tile>\n                            \n                                if(tile === 1) {\n                                    tileToDisplay = <Tile key={innerIndex} tileType=\"snake\"></Tile>\n                                }\n                                else if(tile === 2) {\n                                    tileToDisplay = <Tile key={innerIndex} tileType=\"pellet\"></Tile>\n                                }\n\n                                return tileToDisplay;\n                            })}\n                        </div>\n                    )\n                })}\n            </div>\n        </div>\n    );\n}\n\nexport default Snake;\n","import { useEffect, useRef } from 'react';\n\n// Copied from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nexport function useInterval(callback, delay) {\n    const savedCallback = useRef();\n  \n    // Remember the latest callback.\n    useEffect(() => {\n      savedCallback.current = callback;\n    }, [callback]);\n  \n    // Set up the interval.\n    useEffect(() => {\n      function tick() {\n        savedCallback.current();\n      }\n      if (delay !== null) {\n        let id = setInterval(tick, delay);\n        return () => clearInterval(id);\n      }\n    }, [delay]);\n  }","import './App.css';\nimport Snake from './components/snake';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nfunction App() {\n  return (\n    <Snake></Snake>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}